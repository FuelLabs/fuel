import "./Block.yulp"

/// @title BlockHeader verifier
object "BlockHeader" is "Block" {
  code {
    /// @notice Verifies a rollup block header
    function verifyHeader(blockHeader, root, rootIndex, assertFinalized) {
      // Extract block height from block header
      const blockHeight := BlockHeader.height(blockHeader)
      // Extract transaction roots length from block header
      const rootsLength := BlockHeader.roots.length(blockHeader)

      // Block must not be genesis block
      require(gt(blockHeight, 0),
          error"block-height-underflow")

      // Block height must be at most the tip height
      require(lte(blockHeight, blockTip()),
          error"block-height-overflow")

      // Previous block hash must match with known previous block hash at height
      require(eq(
          blockCommitment(safeSub(blockHeight, 1)),
          BlockHeader.previousBlockHash(blockHeader)),
          error"previous-block-hash")

      // Check bounds on transaction roots length
      require(gt(rootsLength, 0),
          error"roots-length-underflow")
      require(lte(rootsLength, TRANSACTION_ROOTS_MAX),
          error"roots-length-overflow")

      // Block must be known (already committed)
      require(eq(blockCommitment(blockHeight), BlockHeader.keccak256(blockHeader)),
          error"block-commitment")

      // Load finalization delay parameter from constructor
      Constructor.copy(0)
      let finalizationDelay := Constructor.finalizationDelay(0)

      // If assertFinalized set, block must be finalizable
      if eq(assertFinalized, 1) {
        require(gte(
          number(),
          add(BlockHeader.ethereumBlockNumber(blockHeader), finalizationDelay)
        ), error"not-finalized")
      }

      // If assertFinalized not set, block must not be finalizable
      if lt(assertFinalized, 1) {
        require(lt(
          number(), // ethereumBlockNumber
          add(BlockHeader.ethereumBlockNumber(blockHeader), finalizationDelay)
        ), error"block-finalied")
      }

      // If transaction root is present, validate it
      if gt(root, 0) {
        // Check bounds on transaction root index
        require(lt(rootIndex, rootsLength),
            error"root-index-underflow")
        require(lt(rootsLength, TRANSACTION_ROOTS_MAX),
            error"root-index-overflow")

        // Transaction root index must be correct
        require(eq(
            RootHeader.keccak256(root),
            BlockHeader.roots(blockHeader, rootIndex)),
            error"root-block")
      }
    }
  }
}
