import "./Block.yulp"

/// @title BlockHeader verifier
object "BlockHeader" is "Block" {
  code {
    enum AssertFinalized (
      // Assert not finalized
      NotFinalized,
      // Assert finalized
      Finalized,
      // No assertion
      None
    )

    /// @notice Verifies a block header and root header.
    /// @param blockHeader Position in memory of block header object.
    /// @param root Position in memory of root header object. If `0`, only verify the block header, not the root header.
    /// @param rootIndex Position in memory of root index.
    /// @param assertFinalized Enum flag. 0: Assert finalized. 1: Assert not finalized. 2: No assert.
    function verifyHeader(blockHeader, root, rootIndex, assertFinalized) {
      // Extract rollup block height from block header
      const blockHeight := BlockHeader.height(blockHeader)
      // Extract transaction roots length from block header
      const rootsLength := BlockHeader.roots.length(blockHeader)

      // Block must not be genesis block
      require(gt(blockHeight, 0),
          error"block-height-underflow")

      // Block height must be at most the tip height
      require(lte(blockHeight, blockTip()),
          error"block-height-overflow")

      // Previous block hash must match with known previous block hash at height
      require(eq(
          blockCommitment(safeSub(blockHeight, 1)),
          BlockHeader.previousBlockHash(blockHeader)),
          error"previous-block-hash")

      // Check bounds on transaction roots length
      require(gt(rootsLength, 0),
          error"roots-length-underflow")
      require(lte(rootsLength, TRANSACTION_ROOTS_MAX),
          error"roots-length-overflow")

      // Block must be known (already committed)
      require(eq(blockCommitment(blockHeight), BlockHeader.keccak256(blockHeader)),
          error"block-commitment")

      // Load finalization delay parameter from constructor
      Constructor.copy(0)
      let finalizationDelay := Constructor.finalizationDelay(0)

      // If asserting finalized, block must be finalizable
      if eq(assertFinalized, AssertFinalized.Finalized) {
        require(gte(
          number(),
          add(BlockHeader.ethereumBlockNumber(blockHeader), finalizationDelay)
        ), error"not-finalized")
      }

      // If asserting not finalized, block must not be finalizable
      if eq(assertFinalized, AssertFinalized.NotFinalized) {
        require(lt(
          number(),
          add(BlockHeader.ethereumBlockNumber(blockHeader), finalizationDelay)
        ), error"block-finalied")
      }

      // If root header is present, verify it
      if gt(root, 0) {
        // Check bounds on transaction root index
        require(lt(rootIndex, rootsLength),
            error"root-index-underflow")
        // TODO this is redundant, remove (and maybe add check that rootIndex gte 0?)
        require(lt(rootsLength, TRANSACTION_ROOTS_MAX),
            error"root-index-overflow")

        // Hash of root header must match root header hash from proof
        require(eq(
            RootHeader.keccak256(root),
            BlockHeader.roots(blockHeader, rootIndex)),
            error"root-block")
      }
    }
  }
}
