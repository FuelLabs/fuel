import "./verifiers/Witness.yulp"
import "./verifiers/Data.yulp"
import "./verifiers/TransactionProof.yulp"
import "./Fraud.yulp"

/// @title Invalid sum prover
object "InvalidSum" is "TransactionProof", "VerifyData", "VerifyWitness", "Fraud" {
  code {
    /// @notice Fraudulant summing, incase of overflow, we conclude fraud.
    /// @param x The first value to sum.
    /// @param y The second value to sum.
    /// @param transactionProof The fraudulant proof incase summing overflows.
    /// @return z The sum of the two values.
    function assertAddOrFraud(x, y, transactionProof) -> z {
      z := add(x, y)
      assertOrFraud(or(eq(z, x), gt(z, x)), error"summing-overflow", transactionProof)
    }

    /// @notice Fraudulant multiplying, incase of overflow, we conclude fraud.
    /// @param x The first value to multiply.
    /// @param y The second value to multiply.
    /// @return z The multiple of the two values.
    function assertMulOrFraud(x, y, transactionProof) -> z {
      if gt(y, 0) {
        z := mul(x, y)
        assertOrFraud(eq(div(z, y), x), error"summing-mul-overflow", transactionProof)
      }
    }

    /// @notice Compute sum of inputs in token specified in transaction proof.
    /// @param transactionProof Position in memory of transaction proof.
    /// @param inputProofs Position in memory of inputs proofs.
    /// @return Sum of inputs in token.
    function ins(transactionProof, inputProofs) -> sum {
      let pos := TransactionLeaf.inputs.position(TransactionProof.transaction.position(transactionProof))
      let token := tokenId(TransactionProof.tokenAddress(transactionProof))

      for {} lt(pos, TransactionLeaf.inputs.offset(TransactionProof.transaction.position(transactionProof))) {} {
        switch Input.type(pos)

        case InputType.Transfer {
          if eq(token, UTXO.token(inputProofs)) {
            sum := assertAddOrFraud(sum, UTXO.amount(inputProofs), transactionProof)
          }

          inputProofs := add(inputProofs, UTXO.size(inputProofs))
        }

        case InputType.Deposit {
          if eq(token, Deposit.token(inputProofs)) {
            sum := assertAddOrFraud(sum, Deposit.value(inputProofs), transactionProof)
          }

          inputProofs := add(inputProofs, Deposit.size(inputProofs))
        }

        case InputType.HTLC {
          if eq(token, UTXO.token(inputProofs)) {
            sum := assertAddOrFraud(sum, UTXO.amount(inputProofs), transactionProof)
          }

          inputProofs := add(inputProofs, UTXO.size(inputProofs))
        }

        case InputType.Root {
          if eq(token, TransactionProof.feeToken(inputProofs)) {
            sum := assertAddOrFraud(sum, 
              assertMulOrFraud(TransactionProof.fee(inputProofs), TransactionProof.rootLength(inputProofs), transactionProof)
              , transactionProof)
          }

          inputProofs := add(inputProofs, TransactionProof.size(inputProofs))
        }

        default { require(0, error"input-data-length") }

        pos := add(pos, inputSize(pos))
      }
    }

    /// @notice Compute sum of outputs in given token.
    /// @param token Token ID.
    /// @param transactionProof Position in memory of transaction proof.
    /// @return Sum of outputs in token.
    function outs(token, transactionProof) -> sum {
      let leaf := TransactionProof.transaction.position(transactionProof)
      let pos := TransactionLeaf.outputs.position(leaf)
      let end := TransactionLeaf.outputs.offset(leaf)

      for {} lt(pos, end) {} {
        if and(
          lt(Output.type(pos), OutputType.Return),
          eq(token, Output.token.slice(pos))
        ) {
          sum := assertAddOrFraud(sum, outputAmount(pos), transactionProof)
        }

        pos := add(pos, outputSize(pos))
      }
    }

    /// @notice Helper function to prove that sum of outputs violates sum of inputs, assuming proofs are verified.
    /// @param transactionProof Position in memory of transaction proof.
    /// @param inputProofs Position in memory of inputs proofs.
    function proveSum(transactionProof, inputProofs) {
      let token := tokenId(TransactionProof.tokenAddress(transactionProof))
      let outsum := assertAddOrFraud(rootFee(transactionProof, token), outs(token, transactionProof), transactionProof)
      let insum := ins(transactionProof, inputProofs)

      assertOrFraud(eq(outsum, insum), error"sum", transactionProof)
    }

    /// @notice Prove that the sum of outputs violates the sum of inputs.
    /// @param transactionProof Position in memory of transaction proof.
    /// @param inputProofs Position in memory of inputs proofs.
    function proveInvalidSum(transactionProof, inputProofs) {
      verifyTransactionProof(transactionProof, AssertFinalized.NotFinalized)
      verifyWitness(transactionProof, inputProofs)
      verifyData(transactionProof, inputProofs)
      proveSum(transactionProof, inputProofs)
    }
  }
}
