import "./verifiers/TransactionProof.yulp"
import "./Fraud.yulp"
import "./Deposit.yulp"

/// @title Invalid input prover
object "InvalidInput" is "Deposit", "TransactionProof", "Fraud" {
  code {
    /// @notice Prove that an input is invalid.
    /// @param proof Position in memory of proof.
    /// @param transactionProof Position in memory of transaction proof.
    function proveInvalidInput(proof, transactionProof) {
      verifyTransactionProof(transactionProof, AssertFinalized.NotFinalized)
      let input := selectInput(transactionProof)
      let metadata := selectMetadata(transactionProof, TransactionProof.input(transactionProof))

      // Handle Deposit Input
      if eq(Input.type(input), InputType.Deposit) {
        let depositAmount := depositAt(InputDeposit.owner(input),
          MetadataDeposit.token(metadata),
          MetadataDeposit.blockNumber(metadata))

        assertOrFraud(gt(depositAmount, 0), error"input-deposit-value-underflow",
          transactionProof)

        stop()
      }

      // verify the proof
      verifyHeader(TransactionProof.block(proof),
          TransactionProof.root(proof),
          TransactionProof.rootIndex(proof),
          AssertFinalized.None)

      require(eq(Metadata.blockHeight(metadata),
        TransactionProof.blockHeight(proof)), error"block-height-mismatch")

      assertOrFraud(lt(Metadata.rootIndex(metadata),
        TransactionProof.roots.length(proof)), error"input-root-index-overflow", transactionProof)

      require(eq(Metadata.rootIndex(metadata),
        TransactionProof.rootIndex(proof)), error"root-index-mismatch")

      // Handle Root Spend
      if eq(Input.type(input), InputType.Root) {
        stop()
      }

      // Transaction index
      if eq(verifyMerkleProof(proof), false) {
        assertOrFraud(lte(Metadata.transactionIndex(metadata),
          TransactionProof.transactionIndex(proof)), error"input-transaction-index-overflow",
          transactionProof)
      }

      require(eq(Metadata.transactionIndex(metadata),
        TransactionProof.transactionIndex(proof)), error"transaction-index-mismatch")

      assertOrFraud(gt(TransactionProof.transaction.length(proof), 0),
        error"empty-transaction", transactionProof)

      // Output
      let output := selectOutput(proof)

      // Output Index
      assertOrFraud(lt(Metadata.outputIndex(metadata),
        TransactionProof.outputs.length(proof)), error"input-output-index-overflow",
        transactionProof)

      require(eq(Metadata.outputIndex(metadata),
        TransactionProof.output(proof)), error"output-index-mismatch")


      // Output Types
      assertOrFraud(neq(Output.type(output), OutputType.Withdraw),
        error"input-withdraw", transactionProof)

      assertOrFraud(neq(Output.type(output), OutputType.Return),
        error"input-return", transactionProof)


      // Input Checks
      switch Input.type(input)

      case InputType.Transfer {
        assertOrFraud(eq(Output.type(output), OutputType.Transfer),
          error"input-utxo-type", transactionProof)
      }

      case InputType.HTLC {
        assertOrFraud(eq(Output.type(output), OutputType.HTLC),
          error"input-htlc-type", transactionProof)

        if lt(TransactionProof.blockHeight(transactionProof),
          OutputHTLC.expiry(output)) {
          assertOrFraud(eq(OutputHTLC.digest(output),
            InputHTLC.preImage.keccak256(input)), error"htlc-preimage", transactionProof)
        }
      }
    }
  }
}
