{
  "bytecode": "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc03801600138821038831417101561003c57600060005260206000fd5b604081604039506040516060518160005260006020528060406000205550506102f58061006c600039806000f350fe60003681608037600160e01b6080510463a9059cbb8114610081576323b872dd81146100955763095ea7b381146100ab5763dd62ed3e81146100f8576306fdde038114610114576395d89b418114610119576354fd4d50811461011e5763313ce5678114610123576370a0823181146101285761007c82836101ae565b61013c565b61009060a451608451336101c6565b61013c565b6100a660c45160a4516084516101c6565b61013c565b60a4516100bc6001608451336102d1565b5560a4518252608451337f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925602085a360018252602082f361013c565b610108600160a4516084516102d1565b548252602082f361013c565b61013c565b61013c565b61013c565b61013c565b610134826084516102bb565b548252602082f35b5050006102f4565b6000828214838311171561015757600190505b5b92915050565b60008282019050600182821183831417101561017f57600060005260206000fd5b5b92915050565b6000828203905060018282108383141710156101a757600060005260206000fd5b5b92915050565b60018110156101c1578160005260206000fd5b5b5050565b60008181528060205260408120548282528160205283604052604082206060526040604020546101f8600133866102d1565b5461020d635aacdd12888514898611176101ae565b60001981141533861415161561024b5761023463ca3e70e761022f8985610144565b6101ae565b61023e8783610186565b6102498588886102d1565b555b50506102578582610186565b61026183856102bb565b55506102778461027183866102bb565b5461015e565b61028182856102bb565b5583815282827fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef602084a360018152602081f3505b505050565b6000818152826020526040812090505b92915050565b6000818152836020528260405260408120606052604060402090505b9392505050565b",
  "abi": [
    "constructor(address owner, uint256 totalSupply)",
    "transfer(address owner, uint256 amount) public returns (bool success)",
    "transferFrom(address source, address destination, uint amount) public returns (bool success)",
    "approve(address destination, uint256 amount) public returns (bool success)",
    "allowance(address source, address owner) public view returns (uint256 allowance)",
    "name() public view returns (string)",
    "symbol() public view returns (string)",
    "version() public view returns (string)",
    "decimals() public view returns (string)",
    "balanceOf(address owner) public view returns (uint256 balance)",
    "event Approval(address indexed source, address indexed destination, uint256 amount)",
    "event Transfer(address indexed source, address indexed destination, uint amount)"
  ],
  "yul": "object \"ERC20\" {\n  code {\n        function safeAdd(x, y) -> z {\n          z := add(x, y)\n          require(or(eq(z, x), gt(z, x)), 0)\n        }\n        \n        function safeSub(x, y) -> z {\n          z := sub(x, y)\n          require(or(eq(z, x), lt(z, x)), 0)\n        }\n        \n        function safeMul(x, y) -> z {\n          if gt(y, 0) {\n            z := mul(x, y)\n            require(eq(div(z, y), x), 0)\n          }\n        }\n        \n          function safeDiv(x, y) -> z {\n            require(gt(y, 0), 0)\n            z := div(x, y)\n          }\n          \nfunction require(arg, message) {\n  if lt(arg, 1) {\n    mstore(0, message)\n    revert(0, 32)\n  }\n}\n\n     // storage index numbers\n\n    // constructor(address owner, uint256 totalSupply)\n    codecopy(64, safeSub(codesize(), 64), 64)\n\n    // constructor variable\n    let _constructor := 0x00\n\n    // stipulate initial owner and total supply\n    let owner := mload(64)\n    let totalSupply := mload(96)\n\n    // set initial owner balance at totalSupply\n    mstore(0, owner) mstore(add(0,32), 0)\n    sstore(keccak256(0, 64), totalSupply)\n\n    // Goto runtime\n    datacopy(0, dataoffset(\"Runtime\"), datasize(\"Runtime\"))\n    return(0, datasize(\"Runtime\"))\n  }\n  object \"Runtime\" {\n    code {\n  function gte(x, y) -> result {\n    if or(gt(x, y), eq(x, y)) {\n      result := 0x01\n    }\n  }\n  \n  function neq(x, y) -> result {\n    result := iszero(eq(x, y))\n  }\n  \n        function safeAdd(x, y) -> z {\n          z := add(x, y)\n          require(or(eq(z, x), gt(z, x)), 0)\n        }\n        \n        function safeSub(x, y) -> z {\n          z := sub(x, y)\n          require(or(eq(z, x), lt(z, x)), 0)\n        }\n        \n        function safeMul(x, y) -> z {\n          if gt(y, 0) {\n            z := mul(x, y)\n            require(eq(div(z, y), x), 0)\n          }\n        }\n        \n          function safeDiv(x, y) -> z {\n            require(gt(y, 0), 0)\n            z := div(x, y)\n          }\n          \nfunction require(arg, message) {\n  if lt(arg, 1) {\n    mstore(0, message)\n    revert(0, 32)\n  }\n}\n\nfunction mslice(position, length) -> result {\n  result := div(mload(position), exp(2, sub(256, mul(length, 8))))\n}\n\n         // leave first 4 32 byte chunks for hashing, returns etc..\n\n         // storage index numbers\n\n        calldatacopy(128, 0, calldatasize()) // copy all calldata to memory\n\n        switch mslice(128, 4) // 4 byte calldata signature\n\n        case 0xa9059cbb {\n\nfunction transfer.owner(pos) -> res {\n  res := mslice(transfer.owner.position(pos), 32)\n}\n\n\n\nfunction transfer.owner.position(pos) -> _offset {\n  _offset := add(0x04, add(pos, 0))\n}\n\n\n\nfunction transfer.sig.position(pos) -> _offset {\n  _offset := add(0x00, add(pos, 0))\n}\n\n\n\nfunction transfer.amount(pos) -> res {\n  res := mslice(transfer.amount.position(pos), 32)\n}\n\n\n\nfunction transfer.amount.position(pos) -> _offset {\n  _offset := add(0x24, add(pos, 0))\n}\n\n\n            \n\n            transferFrom(caller(),\n                transfer.owner(128),\n                transfer.amount(128))\n        }\n\n        case 0x23b872dd {\n\nfunction transferFromCalldata.source(pos) -> res {\n  res := mslice(transferFromCalldata.source.position(pos), 32)\n}\n\n\n\nfunction transferFromCalldata.source.position(pos) -> _offset {\n  _offset := add(0x04, add(pos, 0))\n}\n\n\n\nfunction transferFromCalldata.sig.position(pos) -> _offset {\n  _offset := add(0x00, add(pos, 0))\n}\n\n\n\nfunction transferFromCalldata.destination(pos) -> res {\n  res := mslice(transferFromCalldata.destination.position(pos), 32)\n}\n\n\n\nfunction transferFromCalldata.destination.position(pos) -> _offset {\n  _offset := add(0x24, add(pos, 0))\n}\n\n\n\nfunction transferFromCalldata.amount(pos) -> res {\n  res := mslice(transferFromCalldata.amount.position(pos), 32)\n}\n\n\n\nfunction transferFromCalldata.amount.position(pos) -> _offset {\n  _offset := add(0x44, add(pos, 0))\n}\n\n\n            \n\n            transferFrom(transferFromCalldata.source(128),\n                transferFromCalldata.destination(128),\n                transferFromCalldata.amount(128))\n        }\n\n        case 0x095ea7b3 {\n\nfunction approve.destination(pos) -> res {\n  res := mslice(approve.destination.position(pos), 32)\n}\n\n\n\nfunction approve.destination.position(pos) -> _offset {\n  _offset := add(0x04, add(pos, 0))\n}\n\n\n\nfunction approve.sig.position(pos) -> _offset {\n  _offset := add(0x00, add(pos, 0))\n}\n\n\n\nfunction approve.amount(pos) -> res {\n  res := mslice(approve.amount.position(pos), 32)\n}\n\n\n\nfunction approve.amount.position(pos) -> _offset {\n  _offset := add(0x24, add(pos, 0))\n}\n\n\n            \n\n            sstore(mappingStorageKey2(caller(),\n                approve.destination(128),\n                1), approve.amount(128))\n\n            mstore(0, approve.amount(128))\n            log3(0, 32,\n                0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925,\n                caller(),\n                approve.destination(128))\n\n            mstore(0, 0x01)\n            return(0, 32)\n        }\n\n        case 0xdd62ed3e {\n\nfunction allowanceCalldata.source(pos) -> res {\n  res := mslice(allowanceCalldata.source.position(pos), 32)\n}\n\n\n\nfunction allowanceCalldata.source.position(pos) -> _offset {\n  _offset := add(0x04, add(pos, 0))\n}\n\n\n\nfunction allowanceCalldata.sig.position(pos) -> _offset {\n  _offset := add(0x00, add(pos, 0))\n}\n\n\n\nfunction allowanceCalldata.owner(pos) -> res {\n  res := mslice(allowanceCalldata.owner.position(pos), 32)\n}\n\n\n\nfunction allowanceCalldata.owner.position(pos) -> _offset {\n  _offset := add(0x24, add(pos, 0))\n}\n\n\n            \n\n            mstore(0, sload(mappingStorageKey2(allowanceCalldata.source(128),\n                allowanceCalldata.owner(128),\n                1)))\n            return (0, 32)\n        }\n\n        case 0x06fdde03 {\n            // mstore(0, \"Fake Dai Stablecoin\") somethig like this, proper but w/ encoding.\n            // return(0, 32)\n        }\n        case 0x95d89b41 {\n            // mstore(0, \"FDAI\")\n            // return(0, 32)\n        }\n        case 0x54fd4d50 {\n            // mstore(0, \"1\")\n            // return(0, 32)\n        }\n        case 0x313ce567 {\n            // mstore(0, 18)\n            // return(0, 32)\n        }\n\n        case 0x70a08231 {\n\nfunction balanceOf.owner(pos) -> res {\n  res := mslice(balanceOf.owner.position(pos), 32)\n}\n\n\n\nfunction balanceOf.owner.position(pos) -> _offset {\n  _offset := add(0x04, add(pos, 0))\n}\n\n\n\nfunction balanceOf.sig.position(pos) -> _offset {\n  _offset := add(0x00, add(pos, 0))\n}\n\n\n            \n            mstore(0, sload(mappingStorageKey(balanceOf.owner(128),\n                0)))\n            return (0, 32)\n        }\n\n        default { require(0, 0) } // invalid method signature\n\n        stop() // stop execution here..\n\n        function transferFrom(source, destination, amount) {\n            let balanceOfSource := sload(mappingStorageKey(source, 0))\n            let allowanceOfDestination := sload(mappingStorageKey2(source, destination, 0))\n            let allowanceOfSourceSender := sload(mappingStorageKey2(source, caller(), 1))\n\n            // require(balanceOf[src] >= wad, \"Dai/insufficient-balance\");\n            require(or(gt(balanceOfSource, amount), eq(balanceOfSource, amount)), 0x5aacdd12)\n\n            // if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            if and(neq(source, caller()), neq(allowanceOfSourceSender, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) {\n                // require(allowance[src][msg.sender] >= wad, \"Dai/insufficient-allowance\");\n                require(gte(allowanceOfDestination, amount), 0xca3e70e7)\n\n                // allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\n                sstore(mappingStorageKey2(source, destination, 0),\n                    safeSub(allowanceOfDestination, amount))\n            }\n\n            //  balanceOf[src] = sub(balanceOf[src], wad);\n            sstore(mappingStorageKey(source, 0),\n                safeSub(balanceOfSource, amount))\n\n            // balanceOf[dst] = add(balanceOf[dst], wad);\n            let balanceOfDestination := sload(mappingStorageKey(destination, 0))\n            sstore(mappingStorageKey(destination, 0),\n                safeAdd(balanceOfDestination, amount))\n\n            mstore(0, amount)\n            log3(0, 32, 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,\n                source, destination)\n\n            mstore(0, 0x01)\n            return(0, 32)\n        }\n\n        // Solidity Style Storage Key: mapping(bytes32 => bytes32)\n        function mappingStorageKey(key, storageIndex) -> storageKey {\n            mstore(0, key) mstore(add(0,32), storageIndex)\n            storageKey := keccak256(0, 64)\n        }\n\n        // Solidity Style Storage Key: mapping(bytes32 => mapping(bytes32 => bytes32)\n        function mappingStorageKey2(key, key2, storageIndex) -> storageKey {\n            mstore(0, key) mstore(add(0,32), storageIndex) mstore(add(0,64), key2)\n            mstore(96, keccak256(0, 64))\n            storageKey := keccak256(64, 64)\n        }\n    }\n  }\n}\n",
  "errors": {
    "insufficient-balance": "0x5aacdd12",
    "insufficient-allowance sdjkfjkkjdfsjkfdsjksdsdfkj": "0xca3e70e7"
  }
}
